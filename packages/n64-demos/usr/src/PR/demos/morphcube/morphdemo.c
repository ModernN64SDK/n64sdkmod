
/*---------------------------------------------------------------------*
        Copyright (C) 1998 Nintendo. (Originated by SGI)
        
        $RCSfile: morphdemo.c,v $
        $Revision: 1.1.1.1 $
        $Date: 2002/05/02 03:27:18 $
 *---------------------------------------------------------------------*/
/*
 * morphdemo.c -- Demonstration of morphing and tiled-mipmapped textures.
 *
 * Features:
 *   - Real time vertex morphing
 *   - CPU work (morphing) is overlapped with rendering
 *   - Lighting
 *   - Tiled and Mipmapped textures
 *
 * Note:  See morphdemo.h for some #define's that can change
 *        program behavior.
 *
 * (c) 1995, Silicon Graphics
 *
 * Bill Mark, June/July 1995
 */

#include <ultra64.h>
#include "morphdemo.h"

/* Threads */
static OSThread mainThread;  /* Started from boot code; becomes idle thread */
static OSThread gameThread;  /* Thread that eventually does all work */

/* Thread priorities */
#define MAIN_PRIORITY 10
#define GAME_PRIORITY 10

/* Thread ID's -- Used only with debugger -- they're arbitrary */
#define MAIN_ID 3
#define GAME_ID 4

u64 bootStack[STACKSIZE/8];  /* For boot code.  Can reuse on boot code exit. */
u64 mainStack[STACKSIZE/8];  /* Stacks for threads... */
u64 gameStack[STACKSIZE/8];

/* Message queue lengths */
#define PI_MSGQUEUE_SIZE   8 /* Not sure what the 'correct' value is.  Should
                                at least roughtly match possible count of
				outstanding PI requests */
#define DMA_MSGQUEUE_SIZE     1
#define RDPDONE_MSGQUEUE_SIZE 1
#define RETRACE_MSGQUEUE_SIZE 1

/* Message queues */
static OSMesg      PiMessages[PI_MSGQUEUE_SIZE];
static OSMesgQueue PiMessageQ;
static OSMesg      DMAMessages[DMA_MSGQUEUE_SIZE];
static OSMesgQueue DMAMessageQ;
static OSMesg      RDPDoneMessages[RDPDONE_MSGQUEUE_SIZE];
static OSMesgQueue RDPDoneMessageQ;
static OSMesg      RetraceMessages[RETRACE_MSGQUEUE_SIZE];
static OSMesgQueue RetraceMessageQ;

/* Dummy message */
static OSMesg      dummyMsg;

/*
 * Symbols generated by "makerom" to tell us where various segments are
 * in cartridge ROM, and in RDRAM.
 */
extern char _rsp_staticSegmentRomStart[],  _rsp_staticSegmentRomEnd[];
extern char _cfbSegmentStart[];
extern char _codeSegmentBssEnd[];


/*
 * Display lists defined in static.c
 */
extern Gfx rspinit_dl[];
extern Gfx rdpinit_dl[];
extern Gfx scrnclr_dl[];
extern Gfx shadetri_dl[];

/*
 * Z-Buffer from zbuf.c; Color Frame Bufs from cfb.c
 */
extern unsigned short zbuffer[];
extern unsigned short cfb_A[];
extern unsigned short cfb_B[];

/*
 * Double-buffered data structures
 * Must be declared global (rather than local to a routine) so that they
 * don't disappear while they're in use when routine exits.
 */
dynamic_stuff dynamic[2];  /* Declare two copies of dynamic stuff */
OSTask        task[2];     /* Two copies of task structure */

/*
 * Protypes for routines in this file
 */
void boot(void *arg);
static void mainproc(void *arg);
static void gameproc(void *arg);
static void gameloop(char *rsp_static_addr);
static void drawframe(dynamic_stuff *generate, Gfx **glistpParam,
		      float t, float rotval);

/*
 * Protypes for routines outside this file
 */
void morph(Vtx **valist, float *weights, int vacnt, Vtx *vout, int vcnt);
void makestuff(void);

/*
 * Cube and square verticies
 */
extern Vtx vcube[];
extern Vtx vsphere[];
extern Gfx mtglist[];     /* display list */

OSPiHandle	*handler;

/*
 * boot -- first routine called
 */
void boot(void *arg) {
  osInitialize();

  handler = osCartRomInit();

  osCreateThread(&mainThread, MAIN_ID, (void(*)(void *))mainproc, arg,
		 (void *)(mainStack+STACKSIZE/8), (OSPri) MAIN_PRIORITY);
  osStartThread(&mainThread);
} /* boot */

/*
 * mainproc -- invoked by boot.  Sets up, then becomes idle thread.
 */
static void mainproc(void *arg) {
  /* Note:  Not using TLB -- all our R4300 address are KSEG0 (physical) */
  
  osCreateThread(&gameThread, GAME_ID, gameproc, arg,
		 (void *)(gameStack+STACKSIZE/8), GAME_PRIORITY);

  /* Start VI Mgr (Video) */
  osCreateViManager(OS_PRIORITY_VIMGR);

  /* Set video mode to Low Res; Anti-Aliased; Non-interlaced; 16 bits/pixel
   * Related values: 1) #define's for SCREEN_WD and HT in morphdemo.h
   *                 2) Element sizes in cfb.c
   *                 3) Address for cfb in 'spec'
   *                 4) gsDP clear instructions in static.c
   */
  osViSetMode(&osViModeTable[OS_VI_NTSC_LAN1]);

  /* Start PI Mgr for access to cartridge
   * This call creates the message queue, so we don't have to.
   */
  osCreatePiManager((OSPri) OS_PRIORITY_PIMGR, &PiMessageQ, PiMessages,
		    PI_MSGQUEUE_SIZE);

  osStartThread(&gameThread);

  /* Become the idle thread and relinquish CPU */
  osSetThreadPri(NULL, 0);
  for(;;); /* This in fact just spins, but OK since we're at priority 0 */
} /* mainproc */

/*
 * gameproc -- entry point for permanently running primary game thread
 */

static void gameproc(void *arg) {
  char     *rsp_static_addr;  /* R4300 addr where rsp_static segment loaded */
  char     *rsp_static_end;   /* R4300 addr+1 for end of the load region    */
  int      rsp_static_len;
  OSIoMesg dmaMb;             /* Needed (empty) for call to osEPiStartDma    */

  /* Message Queue for OS messages indicating DMA completions */
  osCreateMesgQueue(&DMAMessageQ, DMAMessages, DMA_MSGQUEUE_SIZE);

  /* Message Queue for OS messages indicating RDP done */
  osCreateMesgQueue(&RDPDoneMessageQ, RDPDoneMessages, RDPDONE_MSGQUEUE_SIZE);
  osSetEventMesg(OS_EVENT_DP, &RDPDoneMessageQ, dummyMsg);

  /* Message Queue for OS messages indicating vertical retrace */
  osCreateMesgQueue(&RetraceMessageQ, RetraceMessages, RETRACE_MSGQUEUE_SIZE);
  osViSetEvent(&RetraceMessageQ, dummyMsg, 1);

  /*
   * Load the 'rsp_static' segment from the cartridge
   */
  rsp_static_len  = _rsp_staticSegmentRomEnd - _rsp_staticSegmentRomStart;

  /* Place it right after the code/data segment in the 3rd MB of memory.
   * Will not collide with CFB's or the Z buffer. Because the texture loads
   * are so frequent, this gives a significant performance enhancement.
   */
  rsp_static_addr = _codeSegmentBssEnd; /* R4300 address for static segment */
  rsp_static_end  = _codeSegmentBssEnd + rsp_static_len;

#ifdef DEBUG
  if (rsp_static_len > 0x00300000) {
    osSyncPrintf("** Static Segment too large **\n");
  }
#endif

  /* Note: dmaMb is working space used by osEPiStartDma */

  dmaMb.hdr.pri      = OS_MESG_PRI_NORMAL;
  dmaMb.hdr.retQueue = &DMAMessageQ;
  dmaMb.dramAddr     = rsp_static_addr;
  dmaMb.devAddr      = (u32)_rsp_staticSegmentRomStart;
  dmaMb.size         = rsp_static_len;

  osEPiStartDma(handler, &dmaMb, OS_READ);
  osRecvMesg(&DMAMessageQ, NULL, OS_MESG_BLOCK);  /* Wait for completion */

  /*
   * Do the one-time computation of cube and sphere verticies and display
   * list.
   */

  makestuff();

  /*
   * Run the main loop of the game
   */
  gameloop(rsp_static_addr);

} /* gameproc */

/*
 * gameloop -- main loop of game
 *             Called by gameproc; runs in gameThread.
 *             Parameter: rsp_static_addr, the R4300 address where the
 *                        rsp_static segment was loaded
 */
static void gameloop(char *rsp_static_addr) {
  int oddframe = 0;        /* Odd or even rendered frame?  Start with even. */
  int firstframe = 1;      /* First frame? */
  dynamic_stuff *generate; /* Dynamic info we're generating now */
  Gfx           *glistp0;  /* Start of this frame's dynamic display list */
  Gfx           *glistp;   /* Current position in dynamic display list */
  OSTask        *gentask;  /* Task we're generating */
  float         t;         /* Weight of 1st set of morph verticies */
  float         rotval;    /* Current rotation angle in degrees */
  int           dir;       /* Direction in which we're morphing */
  int           pausecnt;  /* Countdown for "stickiness" at morph extremes */

  t = 0.0;
  dir = 1;
  rotval = 0.0;
  pausecnt = 0;
  while (1) {
    /* Start task on RSP, built in previous iteration of loop. */
    if( !firstframe )osSpTaskStart(gentask);

    /*
     * Set up pointers to dynamic stuff.  We're always generating one set
     * of dynamic data and drawing another.
     */
    generate = &(dynamic[(oddframe ? 0 : 1)]);

    /* glist portion of generated dynamic data */
    glistp0 = &(generate->glist[0]);
    glistp  = glistp0;  /* This one will be incremented as list is built */
    
    /*
     * Tell RSP where each segment is
     */
    gSPSegment(glistp++, 0, 0x0);     /* Physical address segment */
    /* Static segment (mapping never changes) */
    gSPSegment(glistp++, STATIC_SEG,  OS_K0_TO_PHYSICAL(rsp_static_addr)); 
    /* Dynamic segment (mapping changes every frame) */
    gSPSegment(glistp++, DYNAMIC_SEG, OS_K0_TO_PHYSICAL(generate));

    /*
     * RSP and RDP setup, and screen clear
     */
    gSPDisplayList(glistp++, rspinit_dl);
    gSPDisplayList(glistp++, rdpinit_dl);
    gDPSetColorImage(glistp++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WD,
		     OS_K0_TO_PHYSICAL(oddframe ? cfb_A : cfb_B));
    gSPDisplayList(glistp++, scrnclr_dl);
    /* Must set color image again after zbuffer clear */
    gDPSetColorImage(glistp++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WD,
		     OS_K0_TO_PHYSICAL(oddframe ? cfb_A : cfb_B));
    /* Set Z-buffer */
    gDPSetDepthImage(glistp++, OS_K0_TO_PHYSICAL(zbuffer));

    /*
     * Matrix setup, and call display list that does real work
     */
    drawframe(generate, &glistp, t, rotval);

    /*
     * Put an END on the top-level display list, and check that we
     * haven't overflowed the buffer.
     */
    gDPFullSync(glistp++); /* Only need this if you want 'accurate' SP done? */
    gSPEndDisplayList(glistp++);

#ifdef DEBUG
    if ((int)(glistp - glistp0) > GLIST_SIZE) {  /* does this check work?? */
      osSyncPrintf("*** GLIST OVERFLOW ***\n");
      /* Could quit here or something */
    } 
#endif

    /*
     * Update morph parameter t
     */
    if (pausecnt == 0) {
      t += dir*(1.0/60.0);           /* A full 60 frames to do the morph */
      if (t < 0.0) {t = 0.0; dir =  1; pausecnt = 60;}
      if (t > 1.0) {t = 1.0; dir = -1; pausecnt = 60;}
    } else {
      pausecnt--;
    }

    /* Update rotation parameter rotval */
    rotval += 1.5;
    if (rotval >= 360.0) rotval = 0.0;

    /*
     * Build graphics task
     * Note that all addresses are KSEG0, even if used by the RSP.
     * Conversion is done by the task routines.
     */
    gentask = &(task[oddframe ? 0 : 1]);
    gentask->t.type            = M_GFXTASK;
    gentask->t.flags           = 0x0;
    gentask->t.ucode_boot      = (u64*) rspbootTextStart;
    gentask->t.ucode_boot_size = ((int)rspbootTextEnd - (int)rspbootTextStart);
    gentask->t.ucode           = (u64*) gspF3DEX2_xbusTextStart; /* use XBUS */
    gentask->t.ucode_data      = (u64*) gspF3DEX2_xbusDataStart;
    gentask->t.ucode_size      = 4096;
    gentask->t.ucode_data_size = 2048;
    gentask->t.dram_stack      = (u64*) dram_stack;
    gentask->t.dram_stack_size = SP_DRAM_STACK_SIZE64;
    gentask->t.output_buff     = (u64*) NULL;
    gentask->t.output_buff_size= (u64*) NULL;
    gentask->t.yield_data_ptr  = (u64*) NULL; /* Graphics only - no yielding */
    gentask->t.yield_data_size = 0x0;
    gentask->t.data_ptr        = (u64*) glistp0;
    gentask->t.data_size       = ((int) glistp - (int) glistp0);

    /* Flush the whole cache.  Should just do parts of it. */
    osWritebackDCacheAll();
    
    /* Wait for task completion (message from RDP) */
    if( !firstframe ){
      osRecvMesg(&RDPDoneMessageQ, NULL, OS_MESG_BLOCK);
      /*
       * Specify frame buffer to be displayed starting at next retrace.
       * We display the one that we've just finished rendering.
       */
      osViSwapBuffer(oddframe ? cfb_B : cfb_A);
    }

    /*
     * Wait for the retrace before rendering next frame
     * (otherwise we might overwrite the frame which is being displayed).
     * But first, make sure that the retrace queue is empty in case we
     * took too long to render the last frame.
     */
    if (MQ_IS_FULL(&RetraceMessageQ))
      osRecvMesg(&RetraceMessageQ, NULL, OS_MESG_NOBLOCK);
    osRecvMesg(&RetraceMessageQ, NULL, OS_MESG_BLOCK);

    /* Switch to our other set of variables  */
    oddframe ^= 1;

    /* No longer the first frame */
    firstframe = 0;

  } /* while(1) */

} /* gameloop */


/*
 * drawframe --  Set up matricies and draw the frame
 *               (by putting entries in display list)
 *
 * t is the morph pararmater [0.0, 1.0]
 * rotval is the rotation parameter, [0.0, 360.0]
 */

static void drawframe(dynamic_stuff *generate, Gfx **glistpParam,
		      float t, float rotval) {
  Gfx   *glistp;
  Vtx   *valist[2]; /* Array of vertex lists */
  float weights[2]; /* Array of weights      */
  u16   perspnorm;
  int i;

  glistp = *glistpParam;  /* Copy to local var */
  /*
   * Set up matricies
   */
  guPerspective(&(generate->projection), &perspnorm,
		45.0, 320.0/240.0, 3500.0, 7500.0, 1.0);
  gSPPerspNormalize(glistp++, perspnorm);

  guRotate(&(generate->modeling_rotate1), 40.0, 1.0, 1.0, 1.0);
  guRotate(&(generate->modeling_rotate2), rotval, 0.0, 1.0, 0.0);
  guTranslate(&(generate->modeling_translate), 0.0, 0.0, -5500.0);
  
  gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(&(generate->projection)),
	    G_MTX_PROJECTION|G_MTX_LOAD|G_MTX_NOPUSH);
  gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(&(generate->modeling_translate)),
	    G_MTX_MODELVIEW|G_MTX_LOAD|G_MTX_NOPUSH);
  gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(&(generate->modeling_rotate2)),
	    G_MTX_MODELVIEW|G_MTX_MUL|G_MTX_NOPUSH);
  gSPMatrix(glistp++, OS_K0_TO_PHYSICAL(&(generate->modeling_rotate1)),
	    G_MTX_MODELVIEW|G_MTX_MUL|G_MTX_NOPUSH);
  
  
  /*
   * Morph, then draw
   */
  valist[0]  = vcube;
  weights[0] = t;
  valist[1]  = vsphere;
  weights[1] = 1.0 - t;
  /* Two sets of key verticies, VCNT verticies per set */
  morph(valist, weights, 2, &(generate->mvlist[0]), VCNT);

#ifdef DO_LIGHTING
  gSPSetGeometryMode(glistp++, G_SHADE | G_SHADING_SMOOTH |
		     G_ZBUFFER | G_LIGHTING | G_CULL_BACK);
#else
  gSPSetGeometryMode(glistp++, G_SHADE | G_SHADING_SMOOTH | G_ZBUFFER |
		     G_CULL_BACK);
#endif

  /* Display the thing! */
  gSPDisplayList(glistp++, OS_K0_TO_PHYSICAL(mtglist));

  *glistpParam = glistp;  /* Copy back from local var */
} /* drawframe */


static void do_init_rsprdp(Gfx *glistp,int oddframe,dynamic_stuff *generate,char *rsp_static_addr)
{
    /*
     * Tell RSP where each segment is
     */
    gSPSegment(glistp++, 0, 0x0);     /* Physical address segment */
    /* Static segment (mapping never changes) */
    gSPSegment(glistp++, STATIC_SEG,  OS_K0_TO_PHYSICAL(rsp_static_addr)); 
    /* Dynamic segment (mapping changes every frame) */
    gSPSegment(glistp++, DYNAMIC_SEG, OS_K0_TO_PHYSICAL(generate));

    /*
     * RSP and RDP setup, and screen clear
     */
    gSPDisplayList(glistp++, rspinit_dl);
    gSPDisplayList(glistp++, rdpinit_dl);
    gDPSetColorImage(glistp++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WD,
		     OS_K0_TO_PHYSICAL(oddframe ? cfb_A : cfb_B));
    gSPDisplayList(glistp++, scrnclr_dl);
    /* Must set color image again after zbuffer clear */
    gDPSetColorImage(glistp++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WD,
		     OS_K0_TO_PHYSICAL(oddframe ? cfb_A : cfb_B));
    /* Set Z-buffer */
    gDPSetDepthImage(glistp++, OS_K0_TO_PHYSICAL(zbuffer));

}
